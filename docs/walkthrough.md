# Manual Setup + Cursor Workflow

The goal is to ultimately remove ambiguity before it can cost you time.

- `create_brief.md` → locks intent
- `business_rules.md` → locks behavior
- `design_schema.md` → locks Prisma models
- `plan_feature.md` → plans implementation
- Cursor implementation → writes code

## Command Directory Structure

docs/
  create_brief.md
  business_rules.md
  design_schema.md
  features/
    0001_PLAN.md

## Project Setup + Pre-Cursor Docs

### Create project folder

```bash
mkdir jeopardy
cd jeopardy
mkdir docs
cd docs
mkdir commands
cd commands
```

### Create pre-implementation docs

```bash
touch create_brief.md
# Paste template and customize using general_pre_implementation_guide.md for reference

touch business_rules.md
# Paste template and customize using game_rules_specification.md for reference
```

### Cursor prompts for pre-cursor docs

```
@create_brief.md
"Confirm you understand the project constraints and rules. Do not write code yet."

@business_rules.md
"Confirm you understand the business rules. Do not write code yet."
```

## Backend + Prisma Environment

### Scaffold NestJS backend

```bash
npx @nestjs/cli new backend
cd backend
```

### Install dependencies

```bash
npm install @nestjs/config @prisma/client prisma
```

### Initialize Prisma

```bash
npx prisma init
# Creates prisma/schema.prisma and .env
```

### Create Supabase project

Copy Session pooler connection string (IPv4-compatible)

Set in `.env`:

```env
DATABASE_URL="postgresql://postgres:[PROJECT_ID]:[PASSWORD]@[POOLER_URL]:5432/postgres"
```

### Configure NestJS to load .env

```typescript
// app.module.ts
import { ConfigModule } from '@nestjs/config';

@Module({
  imports: [ConfigModule.forRoot({ isGlobal: true })],
})
export class AppModule {}
```

## Lock Prisma Schema via Cursor

### Create design_schema.md

```bash
touch design_schema.md
# Paste template for authoritative Prisma schema
```

### Cursor prompt for schema

```
@design_schema.md
"Produce a Prisma schema that represents all domain entities,
relationships, and invariants described in create_brief.md and business_rules.md.
Do not write application code yet."
```

### Replace prisma/schema.prisma

Use Cursor-generated schema

### Run Prisma migration

```bash
npx prisma migrate dev --name init
# Creates tables in Supabase and generates Prisma Client
```

### Generate Prisma client

```bash
npx prisma generate
```

### Create Prisma module and service

```bash
npx nest g module prisma
npx nest g service prisma
```

### Implement PrismaService

```typescript
@Injectable()
export class PrismaService extends PrismaClient implements OnModuleInit {
  async onModuleInit() {
    await this.$connect();
  }
}
```

### Export PrismaService

```typescript
@Module({
  providers: [PrismaService],
  exports: [PrismaService],
})
export class PrismaModule {}
```

## Feature Planning + Cursor Implementation

### Create plan_feature.md

```bash
touch plan_feature.md
# Describe feature: e.g., Create Game endpoint
```

### Cursor prompt to plan feature

```
@plan_feature.md

Feature: Create Game Endpoint

Purpose: Implement the API endpoint to create a new game for a single authenticated user.
Inputs: User ID from JWT
Outputs: Game object with initial score, board state, and metadata
Rules: Follow business_rules.md for game initialization, deterministic state, and persistence
Dependencies: Prisma schema (design_schema.md), backend modules
```

### Cursor generates implementation

Run plan prompt that was generated by the previous prompt

```
"Please implement 1_PLAN.md"
```

## Key Notes

Manual NestJS + Prisma setup prepares environment for Cursor.

Pre-cursor docs (create_brief.md + business_rules.md) lock intent and rules.

Cursor generates schema and feature code, never product decisions.

Replace schema.prisma before migrations.

Follow this order to avoid conflicts, redundant steps, or schema drift.